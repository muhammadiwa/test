import asyncio
from loguru import logger
from decimal import Decimal, getcontext

# Set high precision for decimal calculations
getcontext().prec = 10

async def calculate_buy_from_orderbook(mexc_api, symbol, usdt_amount):
    """
    Calculate optimal buy quantity and price based on order book depth.
    This is especially useful for new listings where market data might be limited.
    
    Args:
        mexc_api: The MEXC API client instance
        symbol: Trading pair symbol (e.g. "BTCUSDT")
        usdt_amount: Amount in USDT to spend
    
    Returns:
        tuple: (expected_quantity, average_price)
    """
    try:
        # Get order book with sufficient depth
        depth = 100  # Request a good depth to see more price levels
        order_book = await mexc_api.get_order_book(symbol, depth)
        
        if not order_book or 'asks' not in order_book:
            logger.warning(f"Could not get order book for {symbol}")
            return None, None
        
        asks = order_book['asks']
        if not asks:
            logger.warning(f"No sell orders found in order book for {symbol}")
            return None, None
        
        # Calculate how many tokens we can buy with the USDT amount
        usdt_remaining = Decimal(str(usdt_amount))
        total_quantity = Decimal('0')
        total_cost = Decimal('0')
        
        for price_level in asks:
            price = Decimal(str(price_level[0]))
            available_qty = Decimal(str(price_level[1]))
            
            # Calculate how much we can buy at this price level
            cost_at_level = price * available_qty
            
            if usdt_remaining >= cost_at_level:
                # We can buy the entire level
                total_quantity += available_qty
                total_cost += cost_at_level
                usdt_remaining -= cost_at_level
            else:
                # We can only buy part of this level
                partial_qty = usdt_remaining / price
                total_quantity += partial_qty
                total_cost += usdt_remaining
                usdt_remaining = Decimal('0')
                break
                
        if total_quantity > 0:
            avg_price = total_cost / total_quantity
            logger.info(f"Order book calculation for {symbol}: {float(total_quantity)} tokens at avg price {float(avg_price)}")
            return float(total_quantity), float(avg_price)
        else:
            logger.warning(f"Could not calculate buy quantity from order book for {symbol}")
            return None, None
            
    except Exception as e:
        logger.error(f"Error calculating from order book for {symbol}: {str(e)}")
        return None, None

async def simulate_market_buy(mexc_api, symbol, usdt_amount):
    """
    Simulate a market buy to estimate execution price and quantity.
    Useful for new listings or low liquidity pairs.
    
    Args:
        mexc_api: The MEXC API client instance
        symbol: Trading pair symbol
        usdt_amount: Amount in USDT to spend
    
    Returns:
        dict: Simulated order result with estimated price and quantity
    """
    quantity, avg_price = await calculate_buy_from_orderbook(mexc_api, symbol, usdt_amount)
    
    if quantity is None:
        return None
        
    # Create a simulated order result
    return {
        'symbol': symbol,
        'side': 'BUY',
        'type': 'MARKET',
        'estimatedPrice': avg_price,
        'estimatedQuantity': quantity,
        'totalCost': usdt_amount,
        'isSimulation': True
    }

async def format_order_book_for_display(mexc_api, symbol, limit=5):
    """
    Format the order book for a symbol in a display-friendly way.
    
    Args:
        mexc_api: The MEXC API client instance
        symbol: Trading pair symbol (e.g. "BTCUSDT")
        limit: Number of price levels to display (default: 5)
    
    Returns:
        str: Formatted order book string for display
    """
    try:
        # Get order book with requested depth
        order_book = await mexc_api.get_order_book(symbol, limit*2)  # Get double the limit to ensure we have enough levels
        
        if not order_book or 'asks' not in order_book or 'bids' not in order_book:
            return "‚ùå Could not retrieve order book."
        
        asks = order_book['asks'][:limit]  # Lowest sell orders
        bids = order_book['bids'][:limit]  # Highest buy orders
        
        # Calculate the spread between best ask and bid
        if asks and bids:
            best_ask = float(asks[0][0])
            best_bid = float(bids[0][0])
            spread = best_ask - best_bid
            spread_percentage = (spread / best_bid) * 100
        else:
            best_ask = "N/A"
            best_bid = "N/A"
            spread = "N/A"
            spread_percentage = "N/A"
        
        # Get current market price
        try:
            ticker = await mexc_api.get_ticker_price(symbol)
            if ticker and isinstance(ticker, dict) and 'price' in ticker:
                current_price = float(ticker['price'])
            elif ticker and isinstance(ticker, list) and ticker:
                # Find the matching pair in the list
                current_price = None
                for item in ticker:
                    if item.get('symbol') == symbol:
                        current_price = float(item['price'])
                        break
                # Fallback to first item
                if current_price is None and 'price' in ticker[0]:
                    current_price = float(ticker[0]['price'])
            else:
                current_price = None
        except Exception:
            current_price = None
            
        # Extract base currency from symbol (e.g., "BTC" from "BTCUSDT")
        base_currency = symbol
        if "USDT" in symbol:
            base_currency = symbol.replace("USDT", "")
            
        # Format the result in a more compact, modern display
        result = f"üîπ {symbol} \n"
            
        # Price information in a nice format
        if current_price:
            # Format price with appropriate precision
            price_str = f"{current_price:.8f}".rstrip('0').rstrip('.')
            
            # Add price line with Ask and Bid
            if spread != "N/A":
                ask_str = f"{best_ask:.8f}".rstrip('0').rstrip('.')
                bid_str = f"{best_bid:.8f}".rstrip('0').rstrip('.')
                result += f"üíπ Price: *{price_str} USDT* | Ask: *{ask_str}* | Bid: *{bid_str}*\n"
                
                # Add spread info
                spread_str = f"{spread:.8f}".rstrip('0').rstrip('.')
                result += f"üìè Spread: *{spread_str}* ({spread_percentage:.2f}%)\n\n"
            else:
                result += f"üíπ Price: *{price_str} USDT*\n\n"
        else:
            result += "üíπ Price information unavailable\n\n"
            
        # Format sell orders (asks) in a compact horizontal format
        sell_prices = []
        for price, amount in asks:
            price_float = float(price)
            amount_float = float(amount)
            price_str = f"{price_float:.8f}".rstrip('0').rstrip('.')
            amount_str = f"{amount_float:.2f}".rstrip('0').rstrip('.')
            sell_prices.append(f"{price_str} ({amount_str})")
            
        # Format buy orders (bids) in a compact horizontal format
        buy_prices = []
        for price, amount in bids:
            price_float = float(price)
            amount_float = float(amount)
            price_str = f"{price_float:.8f}".rstrip('0').rstrip('.')
            amount_str = f"{amount_float:.2f}".rstrip('0').rstrip('.')
            buy_prices.append(f"{price_str} ({amount_str})")
            
        # Add the formatted sell and buy orders
        result += f"üî¥ SELLS: {' | '.join(sell_prices[::-1])}\n"  # Reverse sell orders to show highest first
        result += f"üü¢ BUYS: {' | '.join(buy_prices)}"
        
        return result
        
    except Exception as e:
        return f"‚ùå Error formatting order book: {str(e)}"
